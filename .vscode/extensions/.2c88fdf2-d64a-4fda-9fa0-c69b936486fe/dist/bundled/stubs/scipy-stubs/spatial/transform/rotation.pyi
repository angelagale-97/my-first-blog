# Python: 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Library: scipy, version: 1.6.2
# Module: scipy.spatial.transform.rotation, version: unspecified
import builtins as _mod_builtins
import typing

class Rotation(_mod_builtins.object):
    "Rotation in 3 dimensions.\n\n    This class provides an interface to initialize from and represent rotations\n    with:\n\n    - Quaternions\n    - Rotation Matrices\n    - Rotation Vectors\n    - Modified Rodrigues Parameters\n    - Euler Angles\n\n    The following operations on rotations are supported:\n\n    - Application on vectors\n    - Rotation Composition\n    - Rotation Inversion\n    - Rotation Indexing\n\n    Indexing within a rotation is supported since multiple rotation transforms\n    can be stored within a single `Rotation` instance.\n\n    To create `Rotation` objects use ``from_...`` methods (see examples below).\n    ``Rotation(...)`` is not supposed to be instantiated directly.\n\n    Attributes\n    ----------\n    single\n\n    Methods\n    -------\n    __len__\n    from_quat\n    from_matrix\n    from_rotvec\n    from_mrp\n    from_euler\n    as_quat\n    as_matrix\n    as_rotvec\n    as_mrp\n    as_euler\n    apply\n    __mul__\n    inv\n    magnitude\n    mean\n    reduce\n    create_group\n    __getitem__\n    identity\n    random\n    align_vectors\n\n    See Also\n    --------\n    Slerp\n\n    Notes\n    -----\n    .. versionadded: 1.2.0\n\n    Examples\n    --------\n    >>> from scipy.spatial.transform import Rotation as R\n\n    A `Rotation` instance can be initialized in any of the above formats and\n    converted to any of the others. The underlying object is independent of the\n    representation used for initialization.\n\n    Consider a counter-clockwise rotation of 90 degrees about the z-axis. This\n    corresponds to the following quaternion (in scalar-last format):\n\n    >>> r = R.from_quat([0, 0, np.sin(np.pi/4), np.cos(np.pi/4)])\n\n    The rotation can be expressed in any of the other formats:\n\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n    [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n    [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The same rotation can be initialized using a rotation matrix:\n\n    >>> r = R.from_matrix([[0, -1, 0],\n    ...                    [1, 0, 0],\n    ...                    [0, 0, 1]])\n\n    Representation in other formats:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The rotation vector corresponding to this rotation is given by:\n\n    >>> r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))\n\n    Representation in other formats:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The ``from_euler`` method is quite flexible in the range of input formats\n    it supports. Here we initialize a single rotation about a single axis:\n\n    >>> r = R.from_euler('z', 90, degrees=True)\n\n    Again, the object is representation independent and can be converted to any\n    other format:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n\n    It is also possible to initialize multiple rotations in a single instance\n    using any of the `from_...` functions. Here we initialize a stack of 3\n    rotations using the ``from_euler`` method:\n\n    >>> r = R.from_euler('zyx', [\n    ... [90, 0, 0],\n    ... [0, 45, 0],\n    ... [45, 60, 30]], degrees=True)\n\n    The other representations also now return a stack of 3 rotations. For\n    example:\n\n    >>> r.as_quat()\n    array([[0.        , 0.        , 0.70710678, 0.70710678],\n           [0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n\n    Applying the above rotations onto a vector:\n\n    >>> v = [1, 2, 3]\n    >>> r.apply(v)\n    array([[-2.        ,  1.        ,  3.        ],\n           [ 2.82842712,  2.        ,  1.41421356],\n           [ 2.24452282,  0.78093109,  2.89002836]])\n\n    A `Rotation` instance can be indexed and sliced as if it were a single\n    1D array or list:\n\n    >>> r.as_quat()\n    array([[0.        , 0.        , 0.70710678, 0.70710678],\n           [0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n    >>> p = r[0]\n    >>> p.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> q = r[1:3]\n    >>> q.as_quat()\n    array([[0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n\n    In fact it can be converted to numpy.array:\n\n    >>> r_array = np.asarray(r)\n    >>> r_array.shape\n    (3,)\n    >>> r_array[0].as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n\n    Multiple rotations can be composed using the ``*`` operator:\n\n    >>> r1 = R.from_euler('z', 90, degrees=True)\n    >>> r2 = R.from_rotvec([np.pi/4, 0, 0])\n    >>> v = [1, 2, 3]\n    >>> r2.apply(r1.apply(v))\n    array([-2.        , -1.41421356,  2.82842712])\n    >>> r3 = r2 * r1 # Note the order\n    >>> r3.apply(v)\n    array([-2.        , -1.41421356,  2.82842712])\n\n    Finally, it is also possible to invert rotations:\n\n    >>> r1 = R.from_euler('z', [90, 45], degrees=True)\n    >>> r2 = r1.inv()\n    >>> r2.as_euler('zyx', degrees=True)\n    array([[-90.,   0.,   0.],\n           [-45.,   0.,   0.]])\n\n    These examples serve as an overview into the `Rotation` class and highlight\n    major functionalities. For more thorough examples of the range of input and\n    output formats supported, consult the individual method's examples.\n\n"
    def __getitem__(self, index: int) -> typing.Any:
        "Extract rotation(s) at given index(es) from object.\n\n        Create a new `Rotation` instance containing a subset of rotations\n        stored in this object.\n\n        Parameters\n        ----------\n        indexer : index, slice, or index array\n            Specifies which rotation(s) to extract. A single indexer must be\n            specified, i.e. as if indexing a 1 dimensional array or list.\n\n        Returns\n        -------\n        rotation : `Rotation` instance\n            Contains\n                - a single rotation, if `indexer` is a single index\n                - a stack of rotation(s), if `indexer` is a slice, or and index\n                  array.\n\n        Raises\n        ------\n        TypeError if the instance was created as a single rotation.\n\n        Examples\n        --------\n        >>> from scipy.spatial.transform import Rotation as R\n        >>> r = R.from_quat([\n        ... [1, 1, 0, 0],\n        ... [0, 1, 0, 1],\n        ... [1, 1, -1, 0]])\n        >>> r.as_quat()\n        array([[ 0.70710678,  0.70710678,  0.        ,  0.        ],\n               [ 0.        ,  0.70710678,  0.        ,  0.70710678],\n               [ 0.57735027,  0.57735027, -0.57735027,  0.        ]])\n\n        Indexing using a single index:\n\n        >>> p = r[0]\n        >>> p.as_quat()\n        array([0.70710678, 0.70710678, 0.        , 0.        ])\n\n        Array slicing:\n\n        >>> q = r[1:3]\n        >>> q.as_quat()\n        array([[ 0.        ,  0.70710678,  0.        ,  0.70710678],\n               [ 0.57735027,  0.57735027, -0.57735027,  0.        ]])\n\n"
        ...

    def __getstate__(self) -> typing.Any: ...
    def __init__(self, *args, **kwargs) -> None:
        "Rotation in 3 dimensions.\n\n    This class provides an interface to initialize from and represent rotations\n    with:\n\n    - Quaternions\n    - Rotation Matrices\n    - Rotation Vectors\n    - Modified Rodrigues Parameters\n    - Euler Angles\n\n    The following operations on rotations are supported:\n\n    - Application on vectors\n    - Rotation Composition\n    - Rotation Inversion\n    - Rotation Indexing\n\n    Indexing within a rotation is supported since multiple rotation transforms\n    can be stored within a single `Rotation` instance.\n\n    To create `Rotation` objects use ``from_...`` methods (see examples below).\n    ``Rotation(...)`` is not supposed to be instantiated directly.\n\n    Attributes\n    ----------\n    single\n\n    Methods\n    -------\n    __len__\n    from_quat\n    from_matrix\n    from_rotvec\n    from_mrp\n    from_euler\n    as_quat\n    as_matrix\n    as_rotvec\n    as_mrp\n    as_euler\n    apply\n    __mul__\n    inv\n    magnitude\n    mean\n    reduce\n    create_group\n    __getitem__\n    identity\n    random\n    align_vectors\n\n    See Also\n    --------\n    Slerp\n\n    Notes\n    -----\n    .. versionadded: 1.2.0\n\n    Examples\n    --------\n    >>> from scipy.spatial.transform import Rotation as R\n\n    A `Rotation` instance can be initialized in any of the above formats and\n    converted to any of the others. The underlying object is independent of the\n    representation used for initialization.\n\n    Consider a counter-clockwise rotation of 90 degrees about the z-axis. This\n    corresponds to the following quaternion (in scalar-last format):\n\n    >>> r = R.from_quat([0, 0, np.sin(np.pi/4), np.cos(np.pi/4)])\n\n    The rotation can be expressed in any of the other formats:\n\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n    [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n    [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The same rotation can be initialized using a rotation matrix:\n\n    >>> r = R.from_matrix([[0, -1, 0],\n    ...                    [1, 0, 0],\n    ...                    [0, 0, 1]])\n\n    Representation in other formats:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The rotation vector corresponding to this rotation is given by:\n\n    >>> r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))\n\n    Representation in other formats:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_euler('zyx', degrees=True)\n    array([90.,  0.,  0.])\n\n    The ``from_euler`` method is quite flexible in the range of input formats\n    it supports. Here we initialize a single rotation about a single axis:\n\n    >>> r = R.from_euler('z', 90, degrees=True)\n\n    Again, the object is representation independent and can be converted to any\n    other format:\n\n    >>> r.as_quat()\n    array([0.        , 0.        , 0.70710678, 0.70710678])\n    >>> r.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> r.as_rotvec()\n    array([0.        , 0.        , 1.57079633])\n\n    It is also possible to initialize multiple rotations in a single instance\n    using any of the `from_...` functions. Here we initialize a stack of 3\n    rotations using the ``from_euler`` method:\n\n    >>> r = R.from_euler('zyx', [\n    ... [90, 0, 0],\n    ... [0, 45, 0],\n    ... [45, 60, 30]], degrees=True)\n\n    The other representations also now return a stack of 3 rotations. For\n    example:\n\n    >>> r.as_quat()\n    array([[0.        , 0.        , 0.70710678, 0.70710678],\n           [0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n\n    Applying the above rotations onto a vector:\n\n    >>> v = [1, 2, 3]\n    >>> r.apply(v)\n    array([[-2.        ,  1.        ,  3.        ],\n           [ 2.82842712,  2.        ,  1.41421356],\n           [ 2.24452282,  0.78093109,  2.89002836]])\n\n    A `Rotation` instance can be indexed and sliced as if it were a single\n    1D array or list:\n\n    >>> r.as_quat()\n    array([[0.        , 0.        , 0.70710678, 0.70710678],\n           [0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n    >>> p = r[0]\n    >>> p.as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n    >>> q = r[1:3]\n    >>> q.as_quat()\n    array([[0.        , 0.38268343, 0.        , 0.92387953],\n           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])\n\n    In fact it can be converted to numpy.array:\n\n    >>> r_array = np.asarray(r)\n    >>> r_array.shape\n    (3,)\n    >>> r_array[0].as_matrix()\n    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],\n           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])\n\n    Multiple rotations can be composed using the ``*`` operator:\n\n    >>> r1 = R.from_euler('z', 90, degrees=True)\n    >>> r2 = R.from_rotvec([np.pi/4, 0, 0])\n    >>> v = [1, 2, 3]\n    >>> r2.apply(r1.apply(v))\n    array([-2.        , -1.41421356,  2.82842712])\n    >>> r3 = r2 * r1 # Note the order\n    >>> r3.apply(v)\n    array([-2.        , -1.41421356,  2.82842712])\n\n    Finally, it is also possible to invert rotations:\n\n    >>> r1 = R.from_euler('z', [90, 45], degrees=True)\n    >>> r2 = r1.inv()\n    >>> r2.as_euler('zyx', degrees=True)\n    array([[-90.,   0.,   0.],\n           [-45.,   0.,   0.]])\n\n    These examples serve as an overview into the `Rotation` class and highlight\n    major functionalities. For more thorough examples of the range of input and\n    output formats supported, consult the individual method's examples.\n\n"
        ...

    @classmethod
    def __init_subclass__(cls) -> None:
        "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n"
        ...

    def __len__(self) -> int:
        "Number of rotations contained in this object.\n\n        Multiple rotations can be stored in a single instance.\n\n        Returns\n        -------\n        length : int\n            Number of rotations stored in object.\n\n        Raises\n        ------\n        TypeError if the instance was created as a single rotation.\n"
        ...

    def __mul__(self) -> Rotation:
        "Compose this rotation with the other.\n\n        If `p` and `q` are two rotations, then the composition of 'q followed\n        by p' is equivalent to `p * q`. In terms of rotation matrices,\n        the composition can be expressed as\n        ``p.as_matrix().dot(q.as_matrix())``.\n\n        Parameters\n        ----------\n        other : `Rotation` instance\n            Object containing the rotations to be comp